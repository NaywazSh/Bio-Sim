<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Hydra Anatomy Simulation</title>
    <style>
        :root {
            --bio-green: #a8e063;
            --deep-water: #051911;
        }
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center, #0a2e1f 0%, #000 100%); font-family: 'Segoe UI', Tahoma, sans-serif; color: white; }
        
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            pointer-events: none;
            max-width: 300px;
        }

        .glass-panel {
            background: rgba(10, 30, 20, 0.7);
            backdrop-filter: blur(12px);
            padding: 20px;
            border-radius: 15px;
            border-left: 4px solid var(--bio-green);
            pointer-events: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        h1 { margin: 0; font-size: 1.4rem; color: var(--bio-green); text-transform: uppercase; letter-spacing: 2px; }
        p { font-size: 0.85rem; line-height: 1.5; opacity: 0.8; margin-top: 10px; }

        .annotation {
            position: absolute;
            bottom: 40px;
            right: 40px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--bio-green);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            display: none;
            pointer-events: none;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            opacity: 0.5;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .highlight-text { color: var(--bio-green); font-weight: bold; }
    </style>
</head>
<body>

    <div id="ui-overlay">
        <div class="glass-panel">
            <h1>Hydra Vulgaris</h1>
            <p>A genus of small, fresh-water organisms. They are notable for their regenerative ability—they do not appear to die of old age.</p>
            <div id="interaction-box">
                <p class="highlight-text">Hover over the organism to inspect its anatomy.</p>
            </div>
        </div>
    </div>

    <div id="annotation-panel" class="annotation">
        <strong id="part-name" style="color: var(--bio-green); font-size: 1.1rem;">Part Name</strong><br>
        <span id="part-desc" style="font-size: 0.9rem;">Description goes here...</span>
    </div>

    <div id="controls">Mouse to Rotate • Scroll to Zoom • Interactive Bio-Data</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls, raycaster, mouse;
        let hydraBody, tentacles = [];
        let INTERSECTED;

        const anatomyData = {
            'Tentacles': 'Long, flexible appendages used for locomotion and capturing prey. They contain cnidocytes.',
            'Hypostome': 'The conical structure surrounding the mouth at the top of the body column.',
            'Body Column': 'The main tubular body of the Hydra, capable of extreme contraction and extension.',
            'Basal Disc': 'The foot-like structure used to adhere to surfaces via a sticky secretion.',
            'Cnidocytes': 'Specialized stinging cells used to paralyze prey. They act like microscopic harpoons.'
        };

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a2e1f, 0.05);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 15);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Lights
            const ambient = new THREE.AmbientLight(0x408060, 0.5);
            scene.add(ambient);

            const topLight = new THREE.PointLight(0xa8e063, 2, 30);
            topLight.position.set(5, 10, 5);
            scene.add(topLight);

            const backLight = new THREE.PointLight(0x00ff88, 1, 20);
            backLight.position.set(-5, -5, -5);
            scene.add(backLight);

            createHydra();
            createEnvironment();

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            
            animate();
        }

        function createHydra() {
            const bioMat = new THREE.MeshPhongMaterial({
                color: 0x88ccaa,
                transparent: true,
                opacity: 0.8,
                shininess: 100,
                side: THREE.DoubleSide
            });

            // 1. Body Column
            const bodyGeo = new THREE.CylinderGeometry(0.5, 0.8, 8, 32, 20, true);
            hydraBody = new THREE.Mesh(bodyGeo, bioMat);
            hydraBody.userData.name = 'Body Column';
            scene.add(hydraBody);

            // 2. Hypostome (Mouth area)
            const headGeo = new THREE.SphereGeometry(0.6, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
            const head = new THREE.Mesh(headGeo, bioMat);
            head.position.y = 4;
            head.userData.name = 'Hypostome';
            scene.add(head);

            // 3. Basal Disc (Foot)
            const footGeo = new THREE.CylinderGeometry(1.2, 1.2, 0.4, 32);
            const foot = new THREE.Mesh(footGeo, bioMat);
            foot.position.y = -4;
            foot.userData.name = 'Basal Disc';
            scene.add(foot);

            // 4. Tentacles
            const tentacleCount = 6;
            for (let i = 0; i < tentacleCount; i++) {
                const angle = (i / tentacleCount) * Math.PI * 2;
                
                // Use a Curve for the tentacle
                const curvePoints = [];
                for (let j = 0; j <= 10; j++) {
                    curvePoints.push(new THREE.Vector3(0, j * 0.6, 0));
                }
                const curve = new THREE.CatmullRomCurve3(curvePoints);
                const tentacleGeo = new THREE.TubeGeometry(curve, 20, 0.15, 8, false);
                const tentacle = new THREE.Mesh(tentacleGeo, bioMat);
                
                // Position at top of head
                tentacle.position.set(Math.cos(angle) * 0.4, 4, Math.sin(angle) * 0.4);
                
                // Rotation to spread out
                tentacle.rotation.x = 0.5;
                tentacle.rotation.y = angle;
                
                tentacle.userData.name = 'Tentacles';
                tentacle.userData.angle = angle;
                tentacle.userData.basePos = tentacle.position.clone();
                
                scene.add(tentacle);
                tentacles.push(tentacle);
            }
        }

        function createEnvironment() {
            // Floating organic particles (detritus)
            const pGeo = new THREE.BufferGeometry();
            const pPos = [];
            for (let i = 0; i < 500; i++) {
                pPos.push(THREE.MathUtils.randFloatSpread(40), THREE.MathUtils.randFloatSpread(40), THREE.MathUtils.randFloatSpread(40));
            }
            pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));
            const pMat = new THREE.PointsMaterial({ color: 0xa8e063, size: 0.05, transparent: true, opacity: 0.4 });
            scene.add(new THREE.Points(pGeo, pMat));
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;

            // Biological Movement (Gentle Swaying)
            hydraBody.rotation.z = Math.sin(time * 0.5) * 0.05;
            hydraBody.position.x = Math.sin(time * 0.5) * 0.2;

            tentacles.forEach((tent, i) => {
                const offset = i * 0.5;
                tent.rotation.x = 0.5 + Math.sin(time + offset) * 0.3;
                tent.rotation.z = Math.cos(time + offset) * 0.2;
                
                // Procedural pulse in thickness (simulating nutrient flow)
                const scale = 1 + Math.sin(time * 2 + offset) * 0.05;
                tent.scale.set(scale, 1, scale);
            });

            // Interaction
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children);
            const annotation = document.getElementById('annotation-panel');

            if (intersects.length > 0) {
                const obj = intersects[0].object;
                const name = obj.userData.name;

                if (name && anatomyData[name]) {
                    annotation.style.display = 'block';
                    document.getElementById('part-name').innerText = name;
                    document.getElementById('part-desc').innerText = anatomyData[name];
                    
                    if (INTERSECTED != obj) {
                        if (INTERSECTED && INTERSECTED.material.emissive) INTERSECTED.material.emissive.setHex(0x000000);
                        INTERSECTED = obj;
                        if (INTERSECTED.material.emissive) INTERSECTED.material.emissive.setHex(0x224422);
                    }
                }
            } else {
                annotation.style.display = 'none';
                if (INTERSECTED && INTERSECTED.material.emissive) INTERSECTED.material.emissive.setHex(0x000000);
                INTERSECTED = null;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
